{"sig": "generate_test_case_names(signature: str, preconditions: List, postconditions: List, test_cases: List) -> List", "pre": ["\"signature\" is signature of the function under test", "\"preconditions\" is a list of preconditions of the function under test", "\"postconditions\" is a list of postconditions of the function under test", "\"test_cases\" is a list of test case descriptions"], "post": ["the return value is a json list of test case names suitable for use as Python function names", "the test case names each include the name of the function under test"], "inputs": ["signature is get_function_signature(func: Callable) -> str", "preconditions is ['\"func\" is a Python Callable']", "postconditions is ['the return value is the signature of the function', 'the signature includes the argument type annotations', 'the signature includes the return type annotation', 'The function has a docstring']", "test_cases is [{'description': 'Test with a simple function having no parameters, no return type annotation, and a docstring', 'input': 'def simple_func():\\n    \"\"\"A simple function.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'simple_func() -> None'\", 'reasoning': 'The function meets all preconditions, including having a docstring. The signature correctly indicates no parameters and an implied return type of None.'}, {'description': 'Test with a function having parameters without type annotations, no return type, and a docstring', 'input': 'def param_func(a, b):\\n    \"\"\"A function with parameters but no type annotations.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'param_func(a, b) -> None'\", 'reasoning': 'Despite lacking type annotations and an explicit return type, the function complies with the precondition by including a docstring. The expected signature represents this.'}, {'description': 'Test with a function having parameters and a return type with a docstring', 'input': 'def typed_func(x: int, y: str) -> bool:\\n    \"\"\"A function with typed parameters and a return type.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'typed_func(x: int, y: str) -> bool'\", 'reasoning': 'This function explicitly demonstrates type annotations for both parameters and return type, satisfying preconditions with the presence of a docstring.'}, {'description': 'Test with a higher-order function having a Callable parameter, return type, and a docstring', 'input': 'def higher_order(func: Callable) -> str:\\n    \"\"\"A higher-order function with Callable type annotations.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'higher_order(func: Callable) -> str'\", 'reasoning': 'The function validates handling of Callable type annotations and meets all preconditions by including a docstring.'}, {'description': 'Test with a function having default parameters, type annotations, and a docstring', 'input': 'def default_param_func(a: int = 5) -> None:\\n    \"\"\"A function that demonstrates default parameters.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'default_param_func(a: int = 5) -> None'\", 'reasoning': 'By having default parameters and type annotations, this test explores these aspects. Inclusion of a docstring meets preconditions.'}, {'description': 'Test with a function that returns a complex type and has a docstring', 'input': 'def complex_return() -> List[int]:\\n    \"\"\"A function returning a list of integers.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'complex_return() -> List[int]'\", 'reasoning': 'Through returning a complex type, this test assesses handling of such return types. Presence of a docstring satisfies the preconditions.'}, {'description': 'Test with a lambda function considering its limitations', 'input': 'lambda x: x + 1', 'precondition_met': True, 'expected_result': 'Undefined due to the implicit nature of lambda functions, as they cannot have explicit docstrings or return type annotations.', 'reasoning': 'This test acknowledges the unique characteristics of lambda functions, including the inability to fulfill the precondition regarding docstrings directly.'}, {'description': 'Test with a method of a class, including type annotations, return type, and a docstring', 'input': 'class TestClass:\\n    def class_method(self, y: float) -> None:\\n        \"\"\"A method within a class.\"\"\"\\n        pass', 'precondition_met': True, 'expected_result': \"'TestClass.class_method(self, y: float) -> None'\", 'reasoning': 'This method inside a class provides parameter and return type annotations, along with a docstring, aligning with all preconditions.'}, {'description': 'Test with a function having variadic positional and keyword arguments, and a docstring', 'input': 'def variadic_func(*args, **kwargs) -> None:\\n    \"\"\"A function to test variadic arguments.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'variadic_func(*args, **kwargs) -> None'\", 'reasoning': 'This tests the signature extraction ability with functions having variadic positional and keyword arguments, plus it contains a docstring.'}, {'description': 'Test with an async function, type annotations, return type, and a docstring', 'input': 'async def async_func(a: int) -> None:\\n    \"\"\"An asynchronous function example.\"\"\"\\n    pass', 'precondition_met': True, 'expected_result': \"'async_func(a: int) -> None'\", 'reasoning': 'By being an asynchronous function with type annotations and a docstring, it checks the capturing of async function signatures.'}]"]}